name: Secrets Scan (CI Canary)

on:
  push:
  pull_request:

jobs:
  secrets-scan:
    name: Secrets Scan with Runtime Canary
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Create runtime canary file
        run: |
          mkdir -p __tmp_canary__
          cat > __tmp_canary__/fake-aws-keys.txt << 'EOF'
          # Runtime canary for gitleaks detection - never commit this pattern
          AWS_ACCESS_KEY_ID=AKIA1234567890123456
          AWS_SECRET_ACCESS_KEY=abcdefghijklmnopqrstuvwxyz1234567890ABCD
          EOF
          echo "Created canary file at __tmp_canary__/fake-aws-keys.txt"
      
      - name: Download and run gitleaks
        run: |
          set -euo pipefail
          
          # Download official gitleaks binary for Linux
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks_8.21.2_linux_x64.tar.gz | tar -xz
          chmod +x gitleaks
          
          # Verify gitleaks version
          ./gitleaks version || {
            echo "❌ FAILURE: gitleaks binary verification failed"
            exit 1
          }
          
          # Run gitleaks detect with redaction on the workspace (includes temp canary)
          echo "Running gitleaks detect with redaction..."
          ./gitleaks detect --redact --source . --verbose
          EC=$?
          
          if [ "$EC" -eq 1 ]; then
            echo "✅ SUCCESS: gitleaks detected the runtime canary (expected)"
            exit 0
          elif [ "$EC" -eq 0 ]; then
            echo "❌ FAILURE: gitleaks did NOT detect the canary"
            exit 1
          else
            echo "❌ FAILURE: gitleaks scanner error (exit $EC)"
            exit "$EC"
          fi
      
      - name: Cleanup canary file
        if: always()
        run: |
          rm -rf __tmp_canary__
          echo "Cleaned up canary files"