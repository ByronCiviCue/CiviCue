# Task ID: 38
# Cross-tag dependencies: see .taskmaster/dependencies.md
# Title: Spike: type-extraction scaffold for Socrata adapter (generate TS + Zod from sample payloads)
# Status: pending
# Dependencies: 2
# Priority: medium
# Description: Prototype a generator that produces TypeScript types and Zod schemas for Socrata datasets by combining dataset metadata with sample payloads. Output importable modules the SocrataAdapter can consume.
# Details:
Goal and scope
- Build a CLI scaffold that, given a Socrata domain and dataset ID, fetches column metadata and a small sample of rows, then generates a TS module exporting a Zod schema and inferred TS types. This is a spike: prioritize a workable pipeline, clear interfaces, and documented limitations over completeness.

Outputs
- Generated file per dataset: src/adapters/socrata/types/<datasetId>.ts with:
  - export const <DatasetPascal>Schema: z.ZodObject<...>
  - export type <DatasetPascal> = z.infer<typeof <DatasetPascal>Schema>
  - export const <DatasetPascal>ArraySchema = z.array(<DatasetPascal>Schema)
- Saved fixtures for reproducibility: __fixtures__/socrata/<domain>/<datasetId>/{metadata.json,sample.json}
- Optional per-dataset overrides file (YAML/JSON) to fine-tune ambiguous columns.

CLI interface
- scripts/socrata-typegen.ts (TS, run via tsx):
  - --domain (string, required) e.g., data.sfgov.org
  - --dataset (string, required) 4x4 resource ID
  - --limit (number, default 100)
  - --soql (string, optional) additional $select/$where etc.
  - --outDir (string, default src/adapters/socrata/types)
  - --overrides (path, optional)
  - --save-fixtures (flag)

Data sources
- Metadata: GET https://{domain}/api/views/{dataset}.json (columns[].dataTypeName, name, fieldName, description). Use X-App-Token from env.
- Sample rows: GET https://{domain}/resource/{dataset}.json?$limit={n}&{soql}

Type mapping (baseline from metadata)
- text -> z.string()
- number, money, percent -> z.coerce.number()
- checkbox -> z.coerce.boolean()
- calendar_date -> z.string() (ISO date), optionally refine: .regex(/^\d{4}-\d{2}-\d{2}$/)
- floating_timestamp, fixed_timestamp -> z.string().datetime({ offset: true })
- url -> z.object({ url: z.string().url(), description: z.string().optional() })
- email -> z.string().email()
- phone -> z.string()
- location -> z.object({ latitude: z.coerce.number().nullable(), longitude: z.coerce.number().nullable(), human_address: z.string().nullable().optional() }).nullable()
- point/line/polygon/multipolygon (geo) -> GeoJSON-like zod schemas (Point/LineString/Polygon/MultiPolygon) with number tuples
- json/object -> z.record(z.any()) initially (allow override)

Refinement using samples
- Determine nullability: if a column has nulls in samples, allow z.nullable(); if missing entirely in some rows, mark as optional().
- If same column shows mixed primitive types (e.g., "123" and 123), prefer a coercing schema (z.coerce.number()).
- Low-cardinality text columns (<=10 distinct values in sample): optionally emit z.enum([...]) unless overridden to string.
- Arrays: if sample shows arrays, infer element type recursively; otherwise default to z.array(z.any()).

Overrides mechanism
- Support per-column overrides via overrides file keyed by fieldName, allowing schemas snippets (predefined keywords: number, int, money, enum:[...], date, datetime, string, bool, geo:Point/Polygon, json, custom: <inline zod snippet string>). Apply overrides after baseline mapping.

Codegen
- Build an in-memory AST (e.g., using ts-poet or simple string templates) to emit:
  - Import z from zod
  - A z.object() with keys matching API fieldName (not display name).
  - JSDoc for fields from metadata.description.
  - Type alias via z.infer
  - File header: // AUTO-GENERATED by socrata-typegen. DO NOT EDIT.
- Format output with Prettier, ensure deterministic ordering by fieldName.

Developer experience
- Add npm scripts: "typegen:socrata": "tsx scripts/socrata-typegen.ts"
- README snippet in __docs__/dev/socrata-typegen.md covering usage, overrides, limitations, and how adapter can import schemas.

Adapter integration (optional POC)
- Demonstrate importing a generated schema in a small example function (under examples/ or a unit test) to parse rows from a live call.

Security and ops
- Read env.X_APP_TOKEN (SOCRATA_APP_ID) for higher rate limits. Fail with a clear error if missing and live fetch is requested.
- Respect robots and rate limits; default limit small (<=100). Retries are out-of-scope for this spike (covered by Task 13).

Non-goals
- Full coverage of all Socrata edge data types; 100% perfect inference; wiring schemas into the adapter globally. This is a scaffold to prove the approach and create reusable tooling.

Acceptance criteria
- Run: pnpm typegen:socrata --domain data.sfgov.org --dataset <id> --save-fixtures produces fixtures and a .ts schema module under the outDir.
- Generated module compiles, exports Schema and inferred type, and parses the saved sample rows without errors.
- Overrides file successfully changes a column schema (demonstrated in tests/docs).
- Documentation exists and explains how to add a new dataset.


# Test Strategy:
Unit tests
- Mapping tests: Given synthetic columns metadata with common Socrata types (text, number, money, checkbox, url, email, location, geo, timestamps), assert the produced Zod snippets match the mapping table.
- Nullability/optionality: Provide sample rows with missing and null fields; assert the generated schema uses optional() and/or nullable() correctly.
- Coercion behavior: Samples with "123" and 123 for the same column should produce z.coerce.number().
- Overrides: Apply an overrides file that forces enum, int, or custom geo; assert output reflects overrides.

Snapshot (golden) tests
- Store fixtures for 1â€“2 known SF datasets (e.g., 311 cases and building permits). Run the generator and compare the emitted TS file to a committed snapshot (after normalizing headers/timestamps).

Integration tests (guarded by env)
- If SOCRATA_APP_ID is present, fetch 10 rows from a live dataset, run generator, then import the generated module and parse the fetched rows with the schema; expect success. Mutate a field to violate the schema and expect a Zod error.

Static checks
- Ensure the generated file passes prettier and tsc type-checking in CI.
- Lint for no extraneous any unless explicitly allowed for json/object types.

