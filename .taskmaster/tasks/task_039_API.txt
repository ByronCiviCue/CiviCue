# Task ID: 39
# Cross-tag dependencies: see .taskmaster/dependencies.md
# Title: Spike: type-extraction scaffold for CKAN adapter (generate TS + Zod from datastore_search)
# Status: pending
# Dependencies: 12
# Priority: medium
# Description: Prototype a generator that produces TypeScript types and Zod schemas for CKAN resources using datastore_search metadata and sample rows, outputting importable modules for the CKAN adapter.
# Details:
Goal and scope
- Build a CLI scaffold that, given a CKAN base URL and resource_id, fetches datastore_search metadata (fields) and a small sample of records, then generates a TS module exporting a Zod schema and inferred TS types. Prioritize a workable pipeline, clear interfaces, and documented limitations over completeness.

Inputs
- Required flags: --baseUrl <ckanBaseUrl>, --resourceId <uuid>, --outDir <path>.
- Optional flags: --limit <n> (default 200), --coerceNumbers, --coerceBooleans, --nullableOnNulls (default true), --optionalOnMissing (default true), --titleCaseNames (default true), --index (append export in an index.ts), --dryRun.

CKAN API usage
- GET {baseUrl}/api/3/action/datastore_search?resource_id=<id>&limit=<n> to obtain:
  - result.fields: [{ id, type }...] â€” canonical CKAN field types (e.g., text, numeric, int, float, bool, date, time, timestamp, json, any, geometry, point, _id).
  - result.records: sample rows used to infer optionality, nullability, and coercion needs.
- Optionally detect datastore_search_sql availability, but the spike can rely solely on datastore_search.

Type mapping (initial, explicit and unit-tested)
- text -> z.string()
- int, numeric, float -> z.number() (or z.preprocess to coerce from string when --coerceNumbers)
- bool -> z.boolean() (or z.preprocess to coerce common string/number forms when --coerceBooleans)
- date -> z.string().regex(/^\d{4}-\d{2}-\d{2}$/)
- time -> z.string() (consider regex HH:mm:ss)
- timestamp -> z.string().datetime()
- json/any -> z.any()
- geometry/point (plugin-dependent) -> z.any() with a TODO comment in the generated file
- _id -> z.union([z.number(), z.string()]) (CKAN may emit number or string depending on backend)
- Unknown types -> z.unknown(), with a comment and TODO for manual refinement.

Nullability and optionality inference
- For each field across sample records:
  - If any value is null -> wrap as z.nullable(...)
  - If any record lacks the key -> mark as optional (z.optional(...))
  - If both occur, apply z.optional(z.nullable(...))
- Emit comments summarizing inference evidence (counts of null/missing).

Generated output (per resource)
- Path: src/adapters/ckan/types/<resourceId>.ts
- Contents include:
  - export const <ResourcePascal>Schema = z.object({ ... })
  - export type <ResourcePascal> = z.infer<typeof <ResourcePascal>Schema>
  - Optional: export const <ResourcePascal>FieldMap = { fieldId: 'ckan-type', ... }
  - File header comment with source baseUrl, resourceId, generation timestamp, and CLI options used.
- Example snippet:
  // generated by ckan-types v0.x
  import { z } from 'zod'
  export const StreetTreesSchema = z.object({
    _id: z.union([z.number(), z.string()]),
    species: z.string().optional(),
    planted_at: z.string().datetime().nullable(),
    diameter: z.preprocess(v => (v === null || v === '' ? undefined : Number(v)), z.number()).optional(),
  })
  export type StreetTrees = z.infer<typeof StreetTreesSchema>

Architecture
- Implement a small library with modules: fetchCkanSample.ts, mapCkanTypeToZod.ts, inferNullability.ts, renderModule.ts, writeFile.ts.
- Use node-fetch/undici for HTTP. Respect a simple timeout and basic retry (2 retries on ECONNRESET/ETIMEDOUT/429) with exponential backoff to reduce flakiness.
- Use Prettier to format emitted TS; optionally ts-morph or a template literal approach for codegen. Keep the spike simple and explicit.
- Provide a config file support (ckan-types.config.{ts,js}) to predefine baseUrl and default flags.

Developer ergonomics
- NPM scripts: ckan-types, ckan-types:gen:single, ckan-types:clean.
- Informative console output: shows mappings, any unknown types, and where files were written.
- Fail with non-zero exit if unknown types were encountered unless --allowUnknown is set.

Docs and limitations
- Add README section under adapters/ckan/types/README.md documenting flags, type mapping table, and known limitations (e.g., geometry handling, CSV-backed resources returning strings, limited sample-based inference).
- Emphasize that generated artifacts are intended as a starting point and may need manual edits for complex datasets.


# Test Strategy:
Unit tests
- mapCkanTypeToZod: given representative CKAN field types (text, int, numeric, float, bool, date, time, timestamp, json, geometry, _id), assert the produced Zod AST strings or code snippets match the mapping table (with and without --coerceNumbers/--coerceBooleans).
- inferNullability: feed synthetic records with combinations of missing keys and null values; assert optional/nullable wrapping is applied correctly and comments reflect counts.
- preprocessors: verify numeric and boolean coercion behavior on inputs like '1', '0', 'true', 'false', 1, 0, '  ', null.

Integration tests (mocked network)
- Use msw or nock to mock CKAN responses for datastore_search with a fixed fields list and records sample. Run the CLI to generate files into a temp directory.
- Assert: files are created at the expected path; contents include the expected schema names; Prettier formatting passes; TypeScript compiles; importing the generated module and parsing the mocked records with the schema succeeds.

CLI acceptance tests
- Run the CLI in --dryRun and normal modes, verifying console output (mappings, warnings on unknown types) and exit codes (non-zero when unknown types encountered without --allowUnknown).
- Test flags: --limit affects fetch URL; --index appends export to an index.ts; --titleCaseNames changes exported symbol casing.

Manual verification
- Point the CLI at a public CKAN instance (e.g., demo.ckan.org) with a known resource_id. Confirm schemas roughly match actual data and that parsing a fresh sample set using the generated schema reports sensible results.

